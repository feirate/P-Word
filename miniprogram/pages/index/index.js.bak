const app = getApp()
// å¼•å…¥å®‰å…¨æœåŠ¡æ¨¡å—
const security = require('../../services/security.js')
// å¼•å…¥é«˜è´¨é‡å½•éŸ³æœåŠ¡æ¨¡å—
const audioService = require('../../services/audioService.js')
// å¼•å…¥æ™ºèƒ½è¯­æ–™åº“æœåŠ¡æ¨¡å—
const sentenceService = require('../../services/sentenceService.js')
// å¼•å…¥äº‘æ•°æ®åŒæ­¥æœåŠ¡æ¨¡å—
const cloudService = require('../../services/cloudService.js')
// å¼•å…¥è¯­éŸ³æœ—è¯»æœåŠ¡æ¨¡å—
const ttsService = require('../../services/ttsService.js')

Page({
  data: {
    // åŸºç¡€æ•°æ®
    currentDate: '',
    todayPracticeTime: 0,
    
    // å¥å­ç›¸å…³
    currentSentence: null,
    currentIndex: 0,
    totalSentences: 0,
    showTranslation: false,
    
    // è¯­æ–™åº“ç›¸å…³
    availableCategories: [],
    selectedCategory: '',
    recommendationMode: 'smart', // 'smart', 'sequential', 'random'
    
    // äº‘åŒæ­¥ç›¸å…³
    syncStatus: {
      isOnline: true,
      queueLength: 0,
      lastSyncTime: 0
    },
    showSyncIndicator: false,
    
    // å½•éŸ³ç›¸å…³
    isRecording: false,
    hasRecording: false,
    recordAuth: false,
    recordDuration: 0,
    recordDurationText: '00:00',
    audioPath: '',
    
    // æ³¢å½¢ç›¸å…³
    canvasWidth: 0,
    canvasHeight: 60,
    waveData: [],
    
    // å½•éŸ³è´¨é‡åˆ†æ
    audioQuality: null,
    showQualityTip: false,
    
    // ç»ƒä¹ ç»Ÿè®¡
    practiceStats: {
      sentenceCount: 0,
      totalTime: 0,
      bestScore: null
    },
    
    // UIçŠ¶æ€
    showAuthModal: false,
    
    // æ¸¸æˆåŒ–æ•°æ®
    practiceStreak: 0,           // è¿ç»­ç»ƒä¹ å¤©æ•°
    dailyGoal: 20,               // æ—¥å¸¸ç›®æ ‡å¥æ•°
    goalPercentage: 0,           // ç›®æ ‡å®Œæˆç™¾åˆ†æ¯”
    todayAchievements: [],       // ä»Šæ—¥è·å¾—çš„æˆå°±
    difficultyStars: '',         // éš¾åº¦æ˜Ÿæ˜Ÿæ˜¾ç¤º
    
    // TTS ç›¸å…³
    isTTSPlaying: false,         // TTSæ’­æ”¾çŠ¶æ€
    autoPlayEnabled: true,       // è‡ªåŠ¨æœ—è¯»åŠŸèƒ½
  },

  onLoad() {
    console.log('ğŸ“± ç»ƒä¹ é¡µé¢åŠ è½½')
    
    // ã€å®‰å…¨ã€‘æ¸…ç†è¿‡æœŸæ•°æ®
    security.cleanExpiredData()
    
    // åˆå§‹åŒ–é¡µé¢æ•°æ®
    this.initPageData()
    
    // æ£€æŸ¥å½•éŸ³æƒé™
    this.checkRecordAuth()
    
    // æ ¹æ®æƒé™çŠ¶æ€åˆå§‹åŒ–éŸ³é¢‘æœåŠ¡
    if (app.globalData.recordAuth) {
      this.initAudioService()
      console.log('âœ… å·²æœ‰å½•éŸ³æƒé™ï¼ŒéŸ³é¢‘æœåŠ¡å·²åˆå§‹åŒ–')
    } else {
      console.log('âš ï¸ æš‚æ— å½•éŸ³æƒé™ï¼Œç­‰å¾…ç”¨æˆ·æˆæƒåå†åˆå§‹åŒ–éŸ³é¢‘æœåŠ¡')
    }
    
    // åˆå§‹åŒ–Canvas
    this.initCanvas()
    
    // åˆå§‹åŒ–è¯­æ–™åº“ç³»ç»Ÿ
    this.initSentenceSystem()
    
    // åˆå§‹åŒ–äº‘åŒæ­¥æœåŠ¡
    this.initCloudSync()
    
    // åŠ è½½ä»Šæ—¥ç»Ÿè®¡ï¼ˆä½¿ç”¨å®‰å…¨å­˜å‚¨ï¼‰
    this.loadTodayStats()
    
    // åˆå§‹åŒ–æ¸¸æˆåŒ–æ•°æ®
    this.initGameData()
    
    // ç»˜åˆ¶è¿›åº¦ç¯
    this.drawProgressRing()
    
    // åŠ è½½TTSè®¾ç½®
    this.loadTTSSettings()
  },

  onShow() {
    // é¡µé¢æ˜¾ç¤ºæ—¶æ›´æ–°æ•°æ®
    this.loadTodayStats()
  },

  // åˆå§‹åŒ–é¡µé¢æ•°æ®
  initPageData() {
    const date = new Date()
    const year = date.getFullYear()
    const month = (date.getMonth() + 1).toString().padStart(2, '0')
    const day = date.getDate().toString().padStart(2, '0')
    const currentDate = `${year}.${month}.${day}`
    this.setData({ currentDate })
  },

  // æ£€æŸ¥å½•éŸ³æƒé™
  checkRecordAuth() {
    const recordAuth = app.globalData.recordAuth
    this.setData({ recordAuth })
    
    if (!recordAuth) {
      console.log('âš ï¸ å½•éŸ³æƒé™æœªæˆæƒ')
    }
  },

  // åˆå§‹åŒ–é«˜è´¨é‡å½•éŸ³æœåŠ¡
  initAudioService() {
    // è®¾ç½®å½•éŸ³æœåŠ¡äº‹ä»¶å›è°ƒ
    audioService.setEventHandlers({
      onRecordStart: () => {
        console.log('ğŸ¤ é«˜è´¨é‡å½•éŸ³å¼€å§‹')
        this.setData({ 
          isRecording: true,
          recordDuration: 0,
          waveData: [],
          audioQuality: null
        })
        this.startRecordTimer()
      },
      
      onRecordStop: (result) => {
        console.log('ğŸ¤ å½•éŸ³å®Œæˆ:', result)
        
        // åˆ†æå½•éŸ³è´¨é‡
        const quality = audioService.analyzeAudioQuality()
        
        this.setData({
          isRecording: false,
          hasRecording: true,
          audioPath: result.tempFilePath,
          audioQuality: quality
        })
        
        this.stopRecordTimer()
        this.saveRecordingStats(result)
        
        // æ˜¾ç¤ºå½•éŸ³è´¨é‡æç¤º
        if (quality) {
          this.showQualityFeedback(quality)
        }
      },
      
      onFrameRecorded: (waveData) => {
        this.updateWaveform(waveData)
      },
      
      onRecordError: (error) => {
        console.error('ğŸ¤ å½•éŸ³é”™è¯¯:', error)
        this.setData({ isRecording: false })
        wx.showToast({
          title: 'å½•éŸ³å¤±è´¥ï¼Œè¯·é‡è¯•',
          icon: 'none',
          duration: 2000
        })
      },
      
      onPlayStart: () => {
        console.log('â–¶ï¸ å¼€å§‹æ’­æ”¾å½•éŸ³')
        // å¯ä»¥æ·»åŠ æ’­æ”¾çŠ¶æ€UI
      },
      
      onPlayEnd: () => {
        console.log('â¹ï¸ æ’­æ”¾ç»“æŸ')
        // å¯ä»¥æ·»åŠ æ’­æ”¾ç»“æŸUI
      },
      
      onPlayError: (error) => {
        console.error('âŒ æ’­æ”¾å¤±è´¥:', error)
        wx.showToast({
          title: 'æ’­æ”¾å¤±è´¥',
          icon: 'none'
        })
      }
    })
  },

  // åˆå§‹åŒ–Canvasï¼ˆå¢å¼ºç‰ˆï¼‰
  initCanvas() {
    // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå·²æ¸²æŸ“
    setTimeout(() => {
      const query = this.createSelectorQuery()
      query.select('#waveCanvas').boundingClientRect((rect) => {
        if (rect && rect.width > 0 && rect.height > 0) {
          this.setData({
            canvasWidth: rect.width,
            canvasHeight: rect.height
          })
          console.log(`âœ… Canvasåˆå§‹åŒ–æˆåŠŸ: ${rect.width}x${rect.height}`)
        } else {
          console.warn('âš ï¸ Canvasåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å°ºå¯¸')
          // ä½¿ç”¨é»˜è®¤å°ºå¯¸
          this.setData({
            canvasWidth: 300,
            canvasHeight: 100
          })
        }
      }).exec()
    }, 100) // å»¶è¿Ÿ100ms
  },

  // å¼€å§‹å½•éŸ³
  startRecording() {
    console.log('ğŸ¤ startRecording è¢«è°ƒç”¨', {
      recordAuth: this.data.recordAuth,
      isRecording: this.data.isRecording
    })
    
    if (!this.data.recordAuth) {
      console.log('âŒ æ²¡æœ‰å½•éŸ³æƒé™ï¼Œæ˜¾ç¤ºæˆæƒå¼¹çª—')
      this.showAuthModal()
      return
    }
    
    const success = audioService.startRecording()
    console.log('ğŸ¤ å½•éŸ³å¯åŠ¨ç»“æœ:', success)
    
    if (!success) {
      wx.showToast({
        title: 'å½•éŸ³å¯åŠ¨å¤±è´¥',
        icon: 'none'
      })
    }
  },

  // åœæ­¢å½•éŸ³
  stopRecording() {
    console.log('ğŸ¤ stopRecording è¢«è°ƒç”¨', {
      isRecording: this.data.isRecording
    })
    
    if (this.data.isRecording) {
      const success = audioService.stopRecording()
      console.log('ğŸ¤ å½•éŸ³åœæ­¢ç»“æœ:', success)
    } else {
      console.log('âš ï¸ å½“å‰æ²¡æœ‰å½•éŸ³è¿›è¡Œä¸­')
    }
    
    // æ£€æŸ¥å½•éŸ³è´¨é‡æˆå°±
    setTimeout(() => {
      this.checkTodayAchievements()
    }, 1000)
  },

  // æ’­æ”¾å½•éŸ³
  async playRecording() {
    if (!this.data.hasRecording) {
      wx.showToast({
        title: 'æš‚æ— å½•éŸ³',
        icon: 'none'
      })
      return
    }
    
    try {
      await audioService.playRecording()
    } catch (error) {
      console.error('æ’­æ”¾å¤±è´¥:', error)
    }
  },

  // é‡æ–°å½•éŸ³
  reRecord() {
    // æ¸…ç†å½•éŸ³æœåŠ¡çŠ¶æ€
    audioService.cleanup()
    
    this.setData({
      hasRecording: false,
      audioPath: '',
      waveData: [],
      audioQuality: null
    })
  },

  // åˆ‡æ¢å¥å­
  switchSentence() {
    const nextSentence = this.getNextSentence()
    
    if (nextSentence) {
      this.setData({
        currentSentence: nextSentence,
        showTranslation: false
      })
      
      // æ›´æ–°éš¾åº¦æ˜Ÿæ˜Ÿæ˜¾ç¤º
      this.updateDifficultyStars()
      
      console.log(`ğŸ”„ åˆ‡æ¢åˆ°å¥å­: [${nextSentence.level}] ${nextSentence.content}`)
      
      // è‡ªåŠ¨æœ—è¯»æ–°å¥å­
      if (this.data.autoPlayEnabled) {
        setTimeout(() => {
          this.playTextToSpeech()
        }, 500) // å»¶è¿Ÿ0.5ç§’è®©ç”¨æˆ·é€‚åº”
      }
    }
    
    // æ¸…é™¤å½“å‰å½•éŸ³
    this.setData({
      hasRecording: false,
      audioPath: '',
      waveData: [],
      audioQuality: null
    })
    
    // æ›´æ–°æ¸¸æˆåŒ–æ•°æ®
    this.updateGoalProgress()
    this.updateStreak()
    this.checkTodayAchievements()
  },

  // æ›´æ–°éš¾åº¦æ˜Ÿæ˜Ÿæ˜¾ç¤º
  updateDifficultyStars: function() {
    const { currentSentence } = this.data
    if (currentSentence && currentSentence.difficulty) {
      let stars = ''
      for (let i = 0; i < currentSentence.difficulty; i++) {
        stars += 'â˜…'
      }
      this.setData({ difficultyStars: stars })
    } else {
      this.setData({ difficultyStars: '' })
    }
  },

  // åˆ‡æ¢ç¿»è¯‘æ˜¾ç¤º
  toggleTranslation() {
    this.setData({
      showTranslation: !this.data.showTranslation
    })
  },

  // æ’­æ”¾æ–‡æœ¬æœ—è¯»ï¼ˆTTSï¼‰
  async playTextToSpeech() {
    const { currentSentence, isTTSPlaying } = this.data
    
    if (!currentSentence || !currentSentence.content) {
      console.warn('âš ï¸ æ²¡æœ‰å¯æœ—è¯»çš„å¥å­')
      return
    }
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œåˆ™åœæ­¢
    if (isTTSPlaying) {
      this.stopTextToSpeech()
      return
    }
    
    try {
      console.log('ğŸ”Š å¼€å§‹æœ—è¯»:', currentSentence.content)
      
      // æ›´æ–°æ’­æ”¾çŠ¶æ€
      this.setData({ isTTSPlaying: true })
      
      // è°ƒç”¨TTSæœåŠ¡
      const result = await ttsService.playText(currentSentence.content, {
        rate: 0.8, // ç¨æ…¢ä¸€ç‚¹ï¼Œä¾¿äºå­¦ä¹ 
        volume: 0.9
      })
      
      if (result.success) {
        console.log('âœ… TTSæ’­æ”¾å®Œæˆ')
      } else {
        console.log('â„¹ï¸ TTSæ’­æ”¾ç»“æœ:', result.message)
        let errorMessage = result.message || 'TTSåŠŸèƒ½æš‚ä¸å¯ç”¨'
        if (errorMessage.includes('ä¸æ”¯æŒ') || errorMessage.includes('æ— æ³•') || errorMessage.includes('æ’­æ”¾å¤±è´¥')) {
          errorMessage = 'å½“å‰ç¯å¢ƒä¸æ”¯æŒè¯­éŸ³æ’­æ”¾åŠŸèƒ½'
        }
        wx.showToast({
          title: errorMessage,
          icon: 'none',
          duration: 2000
        })
      }
      
    } catch (error) {
      console.error('âŒ TTSæ’­æ”¾å¤±è´¥:', error)
      wx.showToast({
        title: 'å½“å‰ç¯å¢ƒä¸æ”¯æŒè¯­éŸ³æ’­æ”¾åŠŸèƒ½',
        icon: 'none',
        duration: 2000
      })
    } finally {
      // é‡ç½®æ’­æ”¾çŠ¶æ€
      this.setData({ isTTSPlaying: false })
    }
  },

  // åœæ­¢æ–‡æœ¬æœ—è¯»
  stopTextToSpeech() {
    try {
      ttsService.stopCurrent()
      this.setData({ isTTSPlaying: false })
      console.log('â¹ï¸ TTSæ’­æ”¾å·²åœæ­¢')
    } catch (error) {
      console.error('âŒ åœæ­¢TTSæ—¶å‡ºé”™:', error)
    }
  },

  // åˆ‡æ¢è‡ªåŠ¨æœ—è¯»åŠŸèƒ½
  toggleAutoPlay() {
    const newAutoPlayEnabled = !this.data.autoPlayEnabled
    this.setData({ autoPlayEnabled: newAutoPlayEnabled })
    
    // ä¿å­˜è®¾ç½®åˆ°æœ¬åœ°å­˜å‚¨
    wx.setStorageSync('autoPlayEnabled', newAutoPlayEnabled)
    
    const message = newAutoPlayEnabled ? 'å·²å¼€å¯è‡ªåŠ¨æœ—è¯»' : 'å·²å…³é—­è‡ªåŠ¨æœ—è¯»'
    wx.showToast({
      title: message,
      icon: 'success',
      duration: 1500
    })
    
    console.log(`âš™ï¸ è‡ªåŠ¨æœ—è¯»åŠŸèƒ½: ${newAutoPlayEnabled ? 'å¼€å¯' : 'å…³é—­'}`)
  },

  // åŠ è½½TTSè®¾ç½®
  loadTTSSettings() {
    try {
      const autoPlayEnabled = wx.getStorageSync('autoPlayEnabled')
      if (autoPlayEnabled !== undefined && autoPlayEnabled !== null) {
        this.setData({ autoPlayEnabled })
        console.log(`ğŸ“± å·²åŠ è½½è‡ªåŠ¨æœ—è¯»è®¾ç½®: ${autoPlayEnabled ? 'å¼€å¯' : 'å…³é—­'}`)
      }
    } catch (error) {
      console.warn('âš ï¸ åŠ è½½TTSè®¾ç½®å¤±è´¥:', error)
    }
  },

  // å¼€å§‹å½•éŸ³è®¡æ—¶
  startRecordTimer() {
    this.recordTimer = setInterval(() => {
      const duration = this.data.recordDuration + 1
      const minutes = Math.floor(duration / 60)
      const seconds = duration % 60
      const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
      
      this.setData({
        recordDuration: duration,
        recordDurationText: timeText
      })
    }, 1000)
  },

  // åœæ­¢å½•éŸ³è®¡æ—¶
  stopRecordTimer() {
    if (this.recordTimer) {
      clearInterval(this.recordTimer)
    }
  },

  // æ›´æ–°æ³¢å½¢æ˜¾ç¤ºï¼ˆä¼˜åŒ–ç‰ˆï¼‰
  updateWaveform(waveData) {
    // ç›´æ¥ä½¿ç”¨éŸ³é¢‘æœåŠ¡å¤„ç†è¿‡çš„é«˜è´¨é‡æ³¢å½¢æ•°æ®
    this.setData({ waveData })
    this.drawWaveform()
  },

  // ç»˜åˆ¶æ³¢å½¢ï¼ˆå¢å¼ºç‰ˆï¼Œä¿®å¤Canvas 2Då…¼å®¹æ€§ï¼‰
  drawWaveform() {
    const { canvasWidth, canvasHeight, waveData } = this.data
    
    if (!canvasWidth || waveData.length === 0) return
    
    // ä¼˜å…ˆä½¿ç”¨Canvas 2D APIï¼Œå›é€€åˆ°æ—§ç‰ˆAPI
    this.createSelectorQuery()
      .select('#waveCanvas')
      .fields({
        node: true,
        size: true
      })
      .exec((res) => {
        if (res[0] && res[0].node) {
          // ä½¿ç”¨æ–°çš„Canvas 2D API
          this.drawWaveformNew(res[0])
        } else {
          // å›é€€åˆ°æ—§ç‰ˆCanvas API
          this.drawWaveformLegacy()
        }
      })
  },

  // æ–°ç‰ˆCanvas 2Dç»˜åˆ¶
  drawWaveformNew(canvasInfo) {
    const { canvasWidth, canvasHeight, waveData } = this.data
    
    // æ£€æŸ¥canvasèŠ‚ç‚¹æ˜¯å¦æœ‰æ•ˆ
    if (!canvasInfo || !canvasInfo.node) {
      console.warn('âš ï¸ CanvasèŠ‚ç‚¹æ— æ•ˆï¼Œå›é€€åˆ°æ—§ç‰ˆAPI')
      this.drawWaveformLegacy()
      return
    }
    
    const canvas = canvasInfo.node
    const ctx = canvas.getContext('2d')
    
    // æ£€æŸ¥contextæ˜¯å¦æœ‰æ•ˆ
    if (!ctx) {
      console.warn('âš ï¸ Canvas contextè·å–å¤±è´¥ï¼Œå›é€€åˆ°æ—§ç‰ˆAPI')
      this.drawWaveformLegacy()
      return
    }
    
    // è®¾ç½®ç”»å¸ƒå°ºå¯¸
    const dpr = (wx.getDeviceInfo && wx.getDeviceInfo().pixelRatio) || (wx.getAppBaseInfo && wx.getAppBaseInfo().pixelRatio) || 2
    canvas.width = canvasWidth * dpr
    canvas.height = canvasHeight * dpr
    ctx.scale(dpr, dpr)
    
    // æ¸…é™¤ç”»å¸ƒ
    ctx.clearRect(0, 0, canvasWidth, canvasHeight)
    
    // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
    ctx.strokeStyle = 'rgba(74, 144, 226, 0.1)'
    ctx.lineWidth = 1
    for (let i = 0; i <= 4; i++) {
      const y = (canvasHeight / 4) * i
      ctx.beginPath()
      ctx.moveTo(0, y)
      ctx.lineTo(canvasWidth, y)
      ctx.stroke()
    }
    
    // è®¾ç½®æ³¢å½¢æ ·å¼
    ctx.strokeStyle = '#4A90E2'
    ctx.fillStyle = 'rgba(74, 144, 226, 0.3)'
    ctx.lineWidth = 2
    ctx.lineCap = 'round'
    
    // ç»˜åˆ¶æ³¢å½¢åŒºåŸŸ
    const barWidth = canvasWidth / Math.max(waveData.length, 1)
    const centerY = canvasHeight / 2
    
    if (waveData.length > 0) {
      // ç»˜åˆ¶å¡«å……åŒºåŸŸ
      ctx.beginPath()
      ctx.moveTo(0, centerY)
      
      waveData.forEach((amplitude, index) => {
        const x = index * barWidth
        const height = amplitude * (canvasHeight * 0.7)
        ctx.lineTo(x, centerY - height / 2)
      })
      
      waveData.slice().reverse().forEach((amplitude, index) => {
        const x = (waveData.length - 1 - index) * barWidth
        const height = amplitude * (canvasHeight * 0.7)
        ctx.lineTo(x, centerY + height / 2)
      })
      
      ctx.closePath()
      ctx.fill()
      
      // ç»˜åˆ¶æ³¢å½¢çº¿æ¡
      ctx.beginPath()
      waveData.forEach((amplitude, index) => {
        const x = index * barWidth
        const height = amplitude * (canvasHeight * 0.7)
        
        if (index === 0) {
          ctx.moveTo(x, centerY - height / 2)
        } else {
          ctx.lineTo(x, centerY - height / 2)
        }
      })
      ctx.stroke()
    }
  },

  // æ—§ç‰ˆCanvas APIç»˜åˆ¶ï¼ˆå…¼å®¹æ€§å›é€€ï¼‰
  drawWaveformLegacy() {
    const { canvasWidth, canvasHeight, waveData } = this.data
    const ctx = wx.createCanvasContext('waveCanvas', this)
    
    // æ¸…é™¤ç”»å¸ƒ
    ctx.clearRect(0, 0, canvasWidth, canvasHeight)
    
    // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
    ctx.setStrokeStyle('rgba(74, 144, 226, 0.1)')
    ctx.setLineWidth(1)
    for (let i = 0; i <= 4; i++) {
      const y = (canvasHeight / 4) * i
      ctx.beginPath()
      ctx.moveTo(0, y)
      ctx.lineTo(canvasWidth, y)
      ctx.stroke()
    }
    
    // è®¾ç½®æ³¢å½¢æ ·å¼
    ctx.setStrokeStyle('#4A90E2')
    ctx.setFillStyle('rgba(74, 144, 226, 0.3)')
    ctx.setLineWidth(2)
    ctx.setLineCap('round')
    
    // ç»˜åˆ¶æ³¢å½¢åŒºåŸŸ
    const barWidth = canvasWidth / Math.max(waveData.length, 1)
    const centerY = canvasHeight / 2
    
    if (waveData.length > 0) {
      // ç»˜åˆ¶å¡«å……åŒºåŸŸ
      ctx.beginPath()
      ctx.moveTo(0, centerY)
      
      waveData.forEach((amplitude, index) => {
        const x = index * barWidth
        const height = amplitude * (canvasHeight * 0.7)
        ctx.lineTo(x, centerY - height / 2)
      })
      
      waveData.slice().reverse().forEach((amplitude, index) => {
        const x = (waveData.length - 1 - index) * barWidth
        const height = amplitude * (canvasHeight * 0.7)
        ctx.lineTo(x, centerY + height / 2)
      })
      
      ctx.closePath()
      ctx.fill()
      
      // ç»˜åˆ¶æ³¢å½¢çº¿æ¡
      ctx.beginPath()
      waveData.forEach((amplitude, index) => {
        const x = index * barWidth
        const height = amplitude * (canvasHeight * 0.7)
        
        if (index === 0) {
          ctx.moveTo(x, centerY - height / 2)
        } else {
          ctx.lineTo(x, centerY - height / 2)
        }
      })
      ctx.stroke()
    }
    
    ctx.draw()
  },

  // åˆå§‹åŒ–è¯­æ–™åº“ç³»ç»Ÿ
  async initSentenceSystem() {
    try {
      console.log('ğŸš€ åˆå§‹åŒ–è¯­æ–™åº“ç³»ç»Ÿ...')
      
      // ç­‰å¾…è¯­æ–™åº“åŠ è½½å®Œæˆ
      await sentenceService.initService()
      
      // è·å–å¯ç”¨åˆ†ç±»
      const categories = sentenceService.getAllCategories()
      
      // è·å–æ¨èå¥å­
      const recommendedSentence = sentenceService.getRecommendedSentence()
      
      // æ›´æ–°é¡µé¢æ•°æ®
      this.setData({
        currentSentence: recommendedSentence,
        totalSentences: sentenceService.getTotalCount(),
        availableCategories: categories
      })
      
      // æ›´æ–°éš¾åº¦æ˜Ÿæ˜Ÿæ˜¾ç¤º
      this.updateDifficultyStars()
      
      console.log('âœ… è¯­æ–™åº“ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ')
      console.log(`ğŸ“Š è¯­æ–™åº“ç»Ÿè®¡: ${sentenceService.getTotalCount()} å¥ï¼Œ${categories.length} ä¸ªåˆ†ç±»`)
      
    } catch (error) {
      console.error('âŒ è¯­æ–™åº“ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error)
      
      // ä½¿ç”¨å¤‡ç”¨å¥å­
      this.setData({
        currentSentence: {
          id: 'fallback_001',
          content: 'Hello, how are you?',
          translation: 'ä½ å¥½ï¼Œä½ å¥½å—ï¼Ÿ',
          level: 'åˆçº§',
          category: 'é—®å€™',
          difficulty: 1
        },
        totalSentences: 1,
        availableCategories: ['é—®å€™']
      })
      
      // æ›´æ–°éš¾åº¦æ˜Ÿæ˜Ÿæ˜¾ç¤º
      this.updateDifficultyStars()
    }
  },

  // è·å–ä¸‹ä¸€ä¸ªæ¨èå¥å­
  getNextSentence() {
    const { recommendationMode, selectedCategory, currentSentence } = this.data
    let nextSentence = null
    const currentSentenceId = currentSentence ? currentSentence.id : null

    switch (recommendationMode) {
      case 'smart':
        // æ™ºèƒ½æ¨èï¼ˆè€ƒè™‘ç”¨æˆ·æ°´å¹³ã€ç»ƒä¹ å†å²ç­‰ï¼Œæ’é™¤å½“å‰å¥å­ï¼‰
        let attempts = 0
        do {
          nextSentence = sentenceService.getRecommendedSentence({
            excludeCompleted: attempts === 0, // ç¬¬ä¸€æ¬¡å°è¯•æ’é™¤å·²å®Œæˆçš„
            smartRecommend: true
          })
          attempts++
        } while (nextSentence && nextSentence.id === currentSentenceId && attempts < 5)
        break
        
      case 'category':
        // æŒ‰åˆ†ç±»ç­›é€‰ï¼Œæ’é™¤å½“å‰å¥å­
        if (selectedCategory) {
          const categorySentences = sentenceService.getSentencesByCategory(selectedCategory)
            .filter(s => s.id !== currentSentenceId) // æ’é™¤å½“å‰å¥å­
          if (categorySentences.length > 0) {
            const randomIndex = Math.floor(Math.random() * categorySentences.length)
            nextSentence = categorySentences[randomIndex]
          }
        } else {
          // æ²¡æœ‰é€‰æ‹©åˆ†ç±»æ—¶ï¼Œä»æ‰€æœ‰å¥å­ä¸­éšæœºé€‰æ‹©ï¼ˆæ’é™¤å½“å‰å¥å­ï¼‰
          const allSentences = sentenceService.sentences.filter(s => s.id !== currentSentenceId)
          if (allSentences.length > 0) {
            const randomIndex = Math.floor(Math.random() * allSentences.length)
            nextSentence = allSentences[randomIndex]
          }
        }
        break
        
      case 'sequential':
        // é¡ºåºç»ƒä¹ 
        const currentIndex = this.data.currentIndex
        const totalSentences = sentenceService.getTotalCount()
        const nextIndex = (currentIndex + 1) % totalSentences
        nextSentence = sentenceService.sentences[nextIndex]
        this.setData({ currentIndex: nextIndex })
        break
        
      default:
        // éšæœºé€‰æ‹©ï¼ˆæ’é™¤å½“å‰å¥å­ï¼‰
        const randomSentences = sentenceService.sentences.filter(s => s.id !== currentSentenceId)
        if (randomSentences.length > 0) {
          const randomIndex = Math.floor(Math.random() * randomSentences.length)
          nextSentence = randomSentences[randomIndex]
        }
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„å¥å­ï¼Œfallbackåˆ°ç¬¬ä¸€ä¸ªä¸åŒçš„å¥å­
    if (!nextSentence || nextSentence.id === currentSentenceId) {
      const fallbackSentences = sentenceService.sentences.filter(s => s.id !== currentSentenceId)
      nextSentence = fallbackSentences[0] || sentenceService.sentences[0]
    }

    return nextSentence
  },

  // ã€å®‰å…¨ã€‘ä¿å­˜å½•éŸ³ç»Ÿè®¡ï¼ˆä½¿ç”¨åŠ å¯†å­˜å‚¨ï¼‰
  saveRecordingStats(recordResult) {
    const { recordDuration, currentSentence, audioQuality } = this.data
    
    if (!currentSentence) {
      console.warn('âš ï¸ å½“å‰å¥å­ä¸ºç©ºï¼Œè·³è¿‡ç»Ÿè®¡ä¿å­˜')
      return
    }
    
    // è·å–å½“å‰ç»Ÿè®¡
    const currentStats = security.secureGet('practice_stats') || {
      sentenceCount: 0,
      totalTime: 0,
      bestScore: null,
      lastPracticeDate: null
    }
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    const updatedStats = {
      ...currentStats,
      sentenceCount: currentStats.sentenceCount + 1,
      totalTime: currentStats.totalTime + recordDuration,
      bestScore: Math.max(currentStats.bestScore || 0, audioQuality && audioQuality.quality || 0),
      lastPracticeDate: new Date().toISOString(),
      // ã€éšç§ä¿æŠ¤ã€‘ä¸ä¿å­˜å…·ä½“å½•éŸ³å†…å®¹ï¼Œä»…ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
      version: '1.0',
      timestamp: Date.now()
    }
    
    // ã€å®‰å…¨ã€‘ä½¿ç”¨åŠ å¯†å­˜å‚¨
    security.secureStorage('practice_stats', updatedStats)
    
    // è®°å½•åˆ°è¯­æ–™åº“æœåŠ¡çš„ç»ƒä¹ å†å²
    const practiceRecord = {
      sentenceId: currentSentence.id,
      category: currentSentence.category,
      difficulty: currentSentence.difficulty || 1,
      quality: audioQuality && audioQuality.quality || 60,
      duration: recordDuration
    }
    
    sentenceService.recordPractice(practiceRecord)
    
    // åŒæ­¥ç»ƒä¹ è®°å½•åˆ°äº‘ç«¯
    this.syncPracticeToCloud(practiceRecord)
    
    // æ›´æ–°é¡µé¢æ˜¾ç¤º
    this.setData({
      practiceStats: updatedStats,
      todayPracticeTime: updatedStats.totalTime
    })
    
    console.log('ğŸ“Š ç»ƒä¹ ç»Ÿè®¡å·²ä¿å­˜ï¼ˆåŠ å¯†ï¼‰')
    console.log('ğŸ“ ç»ƒä¹ å†å²å·²è®°å½•åˆ°è¯­æ–™åº“æœåŠ¡')
  },

  // ã€å®‰å…¨ã€‘åŠ è½½ä»Šæ—¥ç»Ÿè®¡ï¼ˆä½¿ç”¨å®‰å…¨è¯»å–ï¼‰
  loadTodayStats() {
    const stats = security.secureGet('practice_stats')
    
    if (stats && security.checkDataIntegrity(stats)) {
      this.setData({
        practiceStats: stats,
        todayPracticeTime: stats.totalTime || 0
      })
      console.log('ğŸ“Š ç»ƒä¹ ç»Ÿè®¡å·²åŠ è½½ï¼ˆè§£å¯†ï¼‰')
    } else {
      console.log('ğŸ“Š æ— æœ‰æ•ˆç»Ÿè®¡æ•°æ®')
    }
  },

  // æ˜¾ç¤ºæƒé™ç”³è¯·å¼¹æ¡†
  showAuthModal() {
    this.setData({ showAuthModal: true })
  },

  // éšè—æƒé™ç”³è¯·å¼¹æ¡†
  hideAuthModal() {
    this.setData({ showAuthModal: false })
  },

  // ç”³è¯·æƒé™ï¼ˆå¢å¼ºéšç§è¯´æ˜ï¼‰
  async requestAuth() {
    try {
      // ã€éšç§ä¿æŠ¤ã€‘è¯¦ç»†è¯´æ˜æƒé™ç”¨é€”
      const modalResult = await wx.showModal({
        title: 'å½•éŸ³æƒé™è¯´æ˜',
        content: 'æˆ‘ä»¬éœ€è¦å½•éŸ³æƒé™ç”¨äºè‹±è¯­å£è¯­ç»ƒä¹ åŠŸèƒ½ã€‚å½•éŸ³æ–‡ä»¶ä»…åœ¨æ‚¨çš„è®¾å¤‡æœ¬åœ°å¤„ç†ï¼Œä¸ä¼šä¸Šä¼ åˆ°æœåŠ¡å™¨æˆ–æ”¶é›†æ‚¨çš„ä¸ªäººä¿¡æ¯ã€‚',
        showCancel: true,
        confirmText: 'åŒæ„',
        cancelText: 'å–æ¶ˆ'
      })
      
      if (!modalResult.confirm) {
        this.setData({ showAuthModal: false })
        return
      }
      
      const authResult = await app.requestRecordAuth()
      if (authResult) {
        this.setData({
          recordAuth: true,
          showAuthModal: false
        })
        
        // æƒé™è·å–æˆåŠŸååˆå§‹åŒ–éŸ³é¢‘æœåŠ¡
        this.initAudioService()
        
        wx.showToast({
          title: 'æƒé™è·å–æˆåŠŸ',
          icon: 'success'
        })
        
        console.log('âœ… å½•éŸ³æƒé™æˆæƒæˆåŠŸï¼ŒéŸ³é¢‘æœåŠ¡å·²åˆå§‹åŒ–')
      }
    } catch (error) {
      console.error('âŒ æƒé™ç”³è¯·å¤±è´¥:', error)
      this.setData({ showAuthModal: false })
      
      // æ˜¾ç¤ºæ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
      wx.showModal({
        title: 'æƒé™è·å–å¤±è´¥',
        content: 'æ— æ³•è·å–å½•éŸ³æƒé™ï¼Œæ‚¨å¯ä»¥ç¨ååœ¨è®¾ç½®é¡µé¢æ‰‹åŠ¨å¼€å¯',
        showCancel: false,
        confirmText: 'çŸ¥é“äº†'
      })
    }
  },

  // æ˜¾ç¤ºå½•éŸ³è´¨é‡åé¦ˆ
  showQualityFeedback(quality) {
    let title = 'å½•éŸ³è´¨é‡åˆ†æ'
    let content = `æ€»è¯„åˆ†ï¼š${quality.quality}åˆ†\n`
    
    if (quality.quality >= 80) {
      title = 'ğŸ‰ å½•éŸ³è´¨é‡ä¼˜ç§€'
      content += 'éŸ³è´¨æ¸…æ™°ï¼Œå½•éŸ³æ•ˆæœå¾ˆå¥½ï¼'
    } else if (quality.quality >= 60) {
      title = 'ğŸ‘ å½•éŸ³è´¨é‡è‰¯å¥½'
      content += 'å½•éŸ³æ•ˆæœä¸é”™ï¼Œç»§ç»­ä¿æŒï¼'
    } else {
      title = 'ğŸ’¡ å½•éŸ³è´¨é‡æç¤º'
      const tips = []
      
      if (quality.avgVolume < 20) {
        tips.push('éŸ³é‡åä½ï¼Œè¯·é è¿‘è¯ç­’')
      }
      if (quality.stability < 70) {
        tips.push('éŸ³é‡ä¸å¤Ÿç¨³å®šï¼Œä¿æŒåŒ€é€Ÿè¯´è¯')
      }
      if (quality.silenceRatio > 30) {
        tips.push('é™éŸ³æ—¶é—´è¾ƒé•¿ï¼Œè¯´è¯æ›´è¿è´¯')
      }
      if (quality.clippingRatio > 5) {
        tips.push('éŸ³é‡è¿‡å¤§ï¼Œè¯·é™ä½è¯´è¯éŸ³é‡')
      }
      
      content += tips.length > 0 ? tips.join('\n') : 'ç»§ç»­ç»ƒä¹ ä¼šæ›´å¥½ï¼'
    }
    
    wx.showModal({
      title,
      content,
      showCancel: false,
      confirmText: 'çŸ¥é“äº†'
    })
  },

  // åˆ‡æ¢è´¨é‡æç¤ºæ˜¾ç¤º
  toggleQualityTip() {
    this.setData({
      showQualityTip: !this.data.showQualityTip
    })
  },

  // åˆ‡æ¢æ¨èæ¨¡å¼
  toggleRecommendationMode() {
    const modes = ['smart', 'category', 'random']
    const currentIndex = modes.indexOf(this.data.recommendationMode)
    const nextIndex = (currentIndex + 1) % modes.length
    const nextMode = modes[nextIndex]

    this.setData({
      recommendationMode: nextMode,
      selectedCategory: '' // é‡ç½®åˆ†ç±»é€‰æ‹©
    })

    const modeNames = {
      smart: 'æ™ºèƒ½æ¨è',
      category: 'åˆ†ç±»ç­›é€‰',
      random: 'éšæœºç»ƒä¹ '
    }

    wx.showToast({
      title: `åˆ‡æ¢åˆ°${modeNames[nextMode]}`,
      icon: 'none',
      duration: 1500
    })

    console.log(`ğŸ”„ æ¨èæ¨¡å¼åˆ‡æ¢åˆ°: ${nextMode}`)
  },

  // é€‰æ‹©åˆ†ç±»
  selectCategory(e) {
    const category = e.currentTarget.dataset.category || ''
    
    this.setData({
      selectedCategory: category
    })

    // æ ¹æ®é€‰æ‹©çš„åˆ†ç±»è·å–æ–°å¥å­
    if (this.data.recommendationMode === 'category') {
      const nextSentence = this.getNextSentence()
      if (nextSentence) {
        this.setData({
          currentSentence: nextSentence,
          showTranslation: false
        })
      }
    }

    const categoryName = category || 'å…¨éƒ¨åˆ†ç±»'
    console.log(`ğŸ“‚ é€‰æ‹©åˆ†ç±»: ${categoryName}`)
  },

  // åˆå§‹åŒ–äº‘åŒæ­¥æœåŠ¡
  initCloudSync() {
    // è·å–åŒæ­¥çŠ¶æ€
    const syncStatus = cloudService.getSyncStatus()
    
    this.setData({
      syncStatus
    })
    
    // å¯åŠ¨æ—¶è‡ªåŠ¨åŒæ­¥ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    const cloudSettings = cloudService.getCloudSettings()
    if (cloudSettings.syncOnLaunch && syncStatus.isOnline) {
      this.performAutoSync()
    }
    
    console.log('â˜ï¸ äº‘åŒæ­¥æœåŠ¡å·²åˆå§‹åŒ–')
  },

  // åŒæ­¥ç»ƒä¹ è®°å½•åˆ°äº‘ç«¯
  async syncPracticeToCloud(practiceRecord) {
    try {
      await cloudService.syncPracticeRecord(practiceRecord)
      
      // æ›´æ–°åŒæ­¥çŠ¶æ€
      const syncStatus = cloudService.getSyncStatus()
      this.setData({ syncStatus })
      
    } catch (error) {
      console.error('ç»ƒä¹ è®°å½•äº‘åŒæ­¥å¤±è´¥:', error)
      // æ˜¾ç¤ºåŒæ­¥å¤±è´¥æŒ‡ç¤ºå™¨
      this.showSyncIndicator('failed')
    }
  },

  // æ‰§è¡Œè‡ªåŠ¨åŒæ­¥
  async performAutoSync() {
    if (!this.data.syncStatus.isOnline) {
      return
    }

    try {
      // æ˜¾ç¤ºåŒæ­¥æŒ‡ç¤ºå™¨
      this.showSyncIndicator('syncing')
      
      // æ‰§è¡ŒåŒæ­¥
      await cloudService.performFullSync()
      
      // æ›´æ–°åŒæ­¥çŠ¶æ€
      const syncStatus = cloudService.getSyncStatus()
      this.setData({ syncStatus })
      
      // æ˜¾ç¤ºåŒæ­¥æˆåŠŸ
      this.showSyncIndicator('success')
      
    } catch (error) {
      console.error('è‡ªåŠ¨åŒæ­¥å¤±è´¥:', error)
      this.showSyncIndicator('failed')
    }
  },

  // æ‰‹åŠ¨è§¦å‘åŒæ­¥
  async manualSync() {
    const result = await cloudService.manualSync()
    
    if (result.success) {
      // æ›´æ–°åŒæ­¥çŠ¶æ€
      const syncStatus = cloudService.getSyncStatus()
      this.setData({ syncStatus })
      
      // é‡æ–°åŠ è½½è¯­æ–™åº“æœåŠ¡æ•°æ®ï¼ˆå¦‚æœæœ‰äº‘ç«¯æ›´æ–°ï¼‰
      sentenceService.loadPracticeHistory()
    }
  },

  // æ˜¾ç¤ºåŒæ­¥æŒ‡ç¤ºå™¨
  showSyncIndicator(type) {
    const indicators = {
      syncing: { icon: 'ğŸ”„', text: 'åŒæ­¥ä¸­...' },
      success: { icon: 'âœ…', text: 'åŒæ­¥å®Œæˆ' },
      failed: { icon: 'âŒ', text: 'åŒæ­¥å¤±è´¥' }
    }
    
    const indicator = indicators[type]
    if (!indicator) return
    
    this.setData({
      showSyncIndicator: true,
      syncIndicator: indicator
    })
    
    // 3ç§’åè‡ªåŠ¨éšè—
    setTimeout(() => {
      this.setData({ showSyncIndicator: false })
    }, 3000)
  },

  // é¡µé¢é”€æ¯æ—¶æ¸…ç†
  onUnload() {
    // æ¸…ç†å®šæ—¶å™¨
    if (this.recordTimer) {
      clearInterval(this.recordTimer)
    }
    
    // æ¸…ç†å½•éŸ³æœåŠ¡
    audioService.cleanup()
    
    // æ¸…ç†TTSæœåŠ¡èµ„æº
    if (ttsService && ttsService.destroy) {
      ttsService.destroy()
    }
    
    // ã€å®‰å…¨ã€‘æ¸…ç†ä¸´æ—¶æ–‡ä»¶ï¼ˆ24å°æ—¶åï¼‰
    const tempFiles = wx.getStorageSync('temp_audio_files') || []
    const now = Date.now()
    const validFiles = tempFiles.filter(file => 
      now - file.timestamp < 24 * 60 * 60 * 1000 // 24å°æ—¶
    )
    wx.setStorageSync('temp_audio_files', validFiles)
  },

  // åˆå§‹åŒ–æ¸¸æˆåŒ–æ•°æ®
  initGameData: function() {
    try {
      // è·å–ç»ƒä¹ è¿å‡»æ•°æ®
      const streakData = wx.getStorageSync('practiceStreak') || {
        count: 0,
        lastDate: null
      };
      
      const today = new Date().toDateString();
      const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
      
      // æ£€æŸ¥è¿å‡»æ˜¯å¦ä¸­æ–­
      if (streakData.lastDate === yesterday || streakData.lastDate === today) {
        this.setData({ practiceStreak: streakData.count });
      } else {
        this.setData({ practiceStreak: 0 });
      }
      
      // è®¡ç®—ç›®æ ‡å®Œæˆç™¾åˆ†æ¯”
      this.updateGoalProgress();
      
      // æ£€æŸ¥ä»Šæ—¥æˆå°±
      this.checkTodayAchievements();
      
    } catch (e) {
      console.error('åˆå§‹åŒ–æ¸¸æˆåŒ–æ•°æ®å¤±è´¥:', e);
    }
  },

  // æ›´æ–°ç›®æ ‡è¿›åº¦
  updateGoalProgress: function() {
    const { sentenceCount } = this.data.practiceStats;
    const { dailyGoal } = this.data;
    const percentage = Math.min(Math.round((sentenceCount / dailyGoal) * 100), 100);
    
    this.setData({ 
      goalPercentage: percentage 
    });
    
    // é‡æ–°ç»˜åˆ¶è¿›åº¦ç¯
    this.drawProgressRing();
  },

  // ç»˜åˆ¶è¿›åº¦ç¯
  drawProgressRing: function() {
    // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå·²æ¸²æŸ“
    setTimeout(() => {
      const query = wx.createSelectorQuery();
      query.select('#progressRing')
        .fields({ node: true, size: true })
        .exec((res) => {
          if (res[0] && res[0].node) {
            const canvas = res[0].node;
            const ctx = canvas.getContext('2d');
            
            if (ctx) {
              const dpr = (wx.getDeviceInfo && wx.getDeviceInfo().pixelRatio) || wx.getAppBaseInfo?.()?.pixelRatio || 2;
              canvas.width = res[0].width * dpr;
              canvas.height = res[0].height * dpr;
              ctx.scale(dpr, dpr);
              
              this.animateProgressRing(ctx, res[0].width, res[0].height);
            } else {
              console.warn('âš ï¸ è¿›åº¦ç¯Canvas contextè·å–å¤±è´¥');
            }
          } else {
            console.warn('âš ï¸ è¿›åº¦ç¯CanvasèŠ‚ç‚¹è·å–å¤±è´¥');
          }
        });
    }, 200); // å»¶è¿Ÿ200ms
  },

  // è¿›åº¦ç¯åŠ¨ç”»
  animateProgressRing: function(ctx, width, height) {
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 2 - 6;
    const { goalPercentage } = this.data;
    
    let currentProgress = 0;
    const targetProgress = goalPercentage;
    const animationDuration = 1000; // 1ç§’åŠ¨ç”»
    const startTime = Date.now();
    const frameRate = 16; // çº¦60fps
    
    const animate = () => {
      const now = Date.now();
      const elapsed = now - startTime;
      const progress = Math.min(elapsed / animationDuration, 1);
      
      // æ¸…é™¤ç”»å¸ƒ
      ctx.clearRect(0, 0, width, height);
      
      // ç»˜åˆ¶èƒŒæ™¯åœ†ç¯
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = 'rgba(33, 150, 243, 0.1)';
      ctx.lineWidth = 8;
      ctx.stroke();
      
      // ç»˜åˆ¶è¿›åº¦åœ†ç¯
      currentProgress = targetProgress * progress;
      const angle = (currentProgress / 100) * 2 * Math.PI - Math.PI / 2;
      
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, -Math.PI / 2, angle);
      
      // åˆ›å»ºæ¸å˜
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, '#2196F3');
      gradient.addColorStop(1, '#1976D2');
      
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.stroke();
      
      if (progress < 1) {
        // ä½¿ç”¨setTimeoutæ›¿ä»£requestAnimationFrame
        setTimeout(animate, frameRate);
      }
    };
    
    animate();
  },

  // æ£€æŸ¥ä»Šæ—¥æˆå°±
  checkTodayAchievements: function() {
    const { practiceStats, practiceStreak } = this.data;
    const achievements = [];
    
    // æ£€æŸ¥å„ç§æˆå°±æ¡ä»¶
    if (practiceStats.sentenceCount >= 10 && practiceStats.sentenceCount % 10 === 0) {
      achievements.push({ id: 'sentences_10', icon: 'ğŸ¯' });
    }
    
    if (practiceStreak >= 7) {
      achievements.push({ id: 'streak_7', icon: 'ğŸ”¥' });
    }
    
    if (practiceStats.bestScore >= 90) {
      achievements.push({ id: 'quality_master', icon: 'ğŸµ' });
    }
    
    if (practiceStats.totalTime >= 30) {
      achievements.push({ id: 'time_master', icon: 'â­' });
    }
    
    this.setData({ todayAchievements: achievements });
  },

  // æ›´æ–°è¿å‡»æ•°æ®
  updateStreak: function() {
    try {
      const today = new Date().toDateString();
      let streakData = wx.getStorageSync('practiceStreak') || {
        count: 0,
        lastDate: null
      };
      
      if (streakData.lastDate !== today) {
        const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toDateString();
        
        if (streakData.lastDate === yesterday) {
          // è¿ç»­ç»ƒä¹ 
          streakData.count += 1;
        } else {
          // é‡æ–°å¼€å§‹
          streakData.count = 1;
        }
        
        streakData.lastDate = today;
        wx.setStorageSync('practiceStreak', streakData);
        
        this.setData({ practiceStreak: streakData.count });
      }
    } catch (e) {
      console.error('æ›´æ–°è¿å‡»æ•°æ®å¤±è´¥:', e);
    }
  },

  // å¿«æ·æ“ä½œæ–¹æ³•
  goToHistory: function() {
    wx.navigateTo({
      url: '/pages/history/history'
    });
  },

  goToLibrary: function() {
    wx.navigateTo({
      url: '/pages/library/library'
    });
  },

  goToSettings: function() {
    wx.navigateTo({
      url: '/pages/settings/settings'
    });
  },

  shareProgress: function() {
    const { practiceStats, practiceStreak } = this.data;
    
    wx.showShareMenu({
      withShareTicket: true,
      menus: ['shareAppMessage', 'shareTimeline']
    });
    
    // å¯ä»¥æ·»åŠ åˆ†äº«é€»è¾‘
    wx.showToast({
      title: 'åˆ†äº«åŠŸèƒ½å¼€å‘ä¸­',
      icon: 'none'
    });
  },
}) 